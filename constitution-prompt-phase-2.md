# Todo App - Phase 2 Constitution

**Project**: Todo Web Application
**Phase**: Phase 2 - Full-Stack Web Application
**Version**: 1.0.0
**Ratified**: 2025-12-11
**Status**: Active

---

## ‚ö†Ô∏è CLAUDE.md Integration (READ FIRST)

**This constitution is coupled with the CLAUDE.md hierarchy. Before any work:**

1. **Read CLAUDE.md files in order:**
   - `CLAUDE.md` (root) - Master project rules and agent/skill references
   - `frontend/CLAUDE.md` - Frontend-specific guidelines
   - `backend/CLAUDE.md` - Backend-specific guidelines

2. **Use Context7 MCP BEFORE implementation:**
   - Always fetch latest library documentation via Context7
   - Never assume API patterns - verify first

3. **Delegate to Specialized Agents:**
   - `@backend-api-builder` for all FastAPI code
   - `@frontend-ui-builder` for all Next.js code
   - `@database-designer` for all database work

4. **Reference Skills for Setup Tasks:**
   - Check `.claude/skills/` before any initialization

**Coupling:** All CLAUDE.md files reference this constitution. This constitution references all CLAUDE.md files. They work together as a unified system.

---

## Project Overview

This is the constitution for the Todo App Hackathon Phase 2, where we transform the console app into a modern multi-user web application with persistent storage. This document defines the principles, standards, and practices that govern the development of this project.

**Goal**: Build a production-ready, full-stack web application using spec-driven development with Claude Code and Spec-Kit Plus.

---

## Core Principles

### I. Spec-Driven Development (NON-NEGOTIABLE)

**Description**: Every feature begins with a specification. Implementation follows specification, never precedes it.

**Rules**:
- Write a complete Markdown specification for every feature before any implementation
- Specifications must include user stories, acceptance criteria, and success metrics
- No code may be written manually - all implementation must be generated by Claude Code from specifications
- Refine specifications until Claude Code generates correct output
- All specifications must be version controlled under `/specs` directory

**Rationale**: Spec-driven development ensures clear requirements, maintainable code, and alignment between intent and implementation.

---

### II. Monorepo Architecture

**Description**: Frontend and backend coexist in a single repository with clear boundaries.

**Structure**:
```
/frontend    - Next.js 16+ application (App Router)
/backend     - Python FastAPI application
/specs       - All specifications organized by type
/history     - All PHRs and ADRs
```

**Rules**:
- Each service (frontend/backend) must be independently deployable
- Shared types and contracts must be documented in `/specs/api`
- No circular dependencies between frontend and backend
- Each service has its own CLAUDE.md with specific guidelines

**Rationale**: Monorepo enables coordinated changes while maintaining clear service boundaries.

---

### III. Test-First Development

**Description**: Tests are written and approved before implementation begins.

**Rules**:
- For every feature, write acceptance tests first
- Tests must fail initially (Red phase)
- Implement until tests pass (Green phase)
- Refactor while keeping tests green
- No feature is complete without passing tests
- Minimum test coverage: 80% for backend, 70% for frontend

**Test Pyramid**:
- Backend: Unit tests, integration tests, API contract tests
- Frontend: Component tests, integration tests, E2E tests (critical paths)

**Rationale**: Test-first development catches bugs early and ensures requirements are met.

---

### IV. Authentication & Authorization First

**Description**: Security is foundational, not an afterthought.

**Rules**:
- Implement Better Auth with JWT tokens from the start
- All API endpoints must validate JWT tokens
- User isolation: users only access their own data
- Store secrets in environment variables, never in code
- Use HTTPS in production
- Implement rate limiting on authentication endpoints

**Security Standards**:
- Passwords: bcrypt hashing with salt
- JWT: Signed with secret, 7-day expiration
- Sessions: Secure, HttpOnly cookies
- CORS: Whitelist frontend origin only

**Rationale**: Security by design prevents vulnerabilities and data breaches.

---

### V. API-First Design

**Description**: Design and document API contracts before implementation.

**Rules**:
- All API endpoints must be documented in `/specs/api/rest-endpoints.md`
- Follow RESTful conventions:
  - GET for retrieval
  - POST for creation
  - PUT for full update
  - PATCH for partial update
  - DELETE for removal
- Return appropriate HTTP status codes
- Use consistent error response format
- Version APIs when breaking changes are needed

**API Response Format**:
```json
{
  "success": true/false,
  "data": { ... },
  "error": { "code": "ERROR_CODE", "message": "Human-readable message" }
}
```

**Rationale**: API-first design ensures frontend and backend can be developed in parallel.

---

### VI. Database-First Schema Design

**Description**: Define database schema before implementing models or queries.

**Rules**:
- Document complete schema in `/specs/database/schema.md`
- Use SQLModel for ORM (combines SQLAlchemy + Pydantic)
- Apply migrations for all schema changes
- Index frequently queried fields
- Enforce foreign key constraints
- Use UUIDs for user IDs, integers for task IDs

**Schema Standards**:
- Every table has: `created_at`, `updated_at` timestamps
- Soft deletes where appropriate (add `deleted_at` field)
- Consistent naming: snake_case for columns
- Document all relationships and constraints

**Rationale**: Schema-first design prevents data integrity issues and migration headaches.

---

### VII. Modern UI/UX Standards

**Description**: Build beautiful, accessible, responsive user interfaces.

**Tech Stack**:
- **Framework**: Next.js 16+ with App Router
- **Styling**: Tailwind CSS 4.0
- **Components**: Shadcn/ui (copy-paste components)
- **Animations**: Framer Motion (smooth transitions)
- **Effects**: Aceternity UI (stunning visual effects)

**Rules**:
- Mobile-first responsive design
- Dark mode support from day one
- Accessibility: WCAG 2.1 Level AA compliance
- Loading states for all async operations
- Error boundaries for graceful error handling
- Optimistic UI updates for better UX

**Performance Standards**:
- First Contentful Paint (FCP) < 1.5s
- Time to Interactive (TTI) < 3.5s
- Lighthouse score > 90

**Rationale**: Modern UI/UX standards create delightful user experiences and professional applications.

---

### VIII. Observability & Debugging

**Description**: Applications must be observable and debuggable in production.

**Rules**:
- Structured logging (JSON format)
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Include request IDs in all logs for tracing
- Log all authentication attempts
- Log all database errors
- Never log sensitive data (passwords, tokens)

**Monitoring**:
- API response times
- Error rates
- Database query performance
- Authentication failures

**Rationale**: Observability enables rapid debugging and performance optimization.

---

### IX. Documentation & Knowledge Capture

**Description**: Every decision, conversation, and architectural choice must be documented.

**Documentation Requirements**:
1. **Prompt History Records (PHRs)**: Record every user interaction and Claude Code session
2. **Architecture Decision Records (ADRs)**: Document significant architectural decisions
3. **README.md**: Setup instructions, tech stack, deployment guide
4. **API Documentation**: Complete endpoint documentation with examples
5. **Component Documentation**: Storybook or similar for UI components

**PHR Creation** (after every user request):
- Route to appropriate subfolder: `history/prompts/{constitution|general|feature-name}/`
- Include: ID, title, stage, user prompt, assistant response, files changed
- Use templates from `.specify/templates/phr-template.prompt.md`

**ADR Suggestion** (for significant decisions):
- Test for significance: Impact + Alternatives + Scope
- Suggest: "üìã Architectural decision detected: [brief] ‚Äî Document? Run `/sp.adr [title]`"
- Never auto-create; wait for user consent

**Rationale**: Documentation preserves knowledge and accelerates onboarding.

---

### X. Progressive Enhancement

**Description**: Build incrementally from simple to complex.

**Approach**:
1. **Phase 2A**: Basic CRUD (Add, View, Update, Delete, Mark Complete)
2. **Phase 2B**: Authentication & Multi-user support
3. **Phase 2C**: Advanced features (if time permits)

**Rules**:
- Deliver working software at each sub-phase
- Each increment must be deployable
- Don't build features that aren't in the spec
- Refactor only when necessary
- Keep it simple (YAGNI - You Aren't Gonna Need It)

**Rationale**: Progressive enhancement delivers value early and reduces risk.

---

## Technology Stack

### Frontend
- **Framework**: Next.js 16+ (App Router, Server Components, Server Actions)
- **Language**: TypeScript 5.0+
- **Styling**: Tailwind CSS 4.0
- **Components**: Shadcn/ui (Radix UI primitives)
- **Animation**: Framer Motion 11+
- **Effects**: Aceternity UI (stunning visual effects)
- **Forms**: React Hook Form + Zod validation
- **HTTP Client**: Axios 1.7+ (MANDATORY - NO fetch for API calls)
- **State**: Zustand 5.0+ (MANDATORY - NO React Context for state)

### Backend
- **Framework**: FastAPI 0.115+
- **Language**: Python 3.13+
- **ORM**: SQLModel 0.0.24+ (SQLAlchemy 2.0 + Pydantic 2.0)
- **Database**: Neon Serverless PostgreSQL
- **Authentication**: Better Auth (JWT tokens)
- **Validation**: Pydantic 2.0
- **Testing**: pytest 8.0+, httpx (for API tests)
- **Package Manager**: UV (fast Python package manager)

### Infrastructure
- **Frontend Hosting**: Vercel
- **Backend Hosting**: Vercel (Python runtime) or Railway
- **Database**: Neon Serverless PostgreSQL (free tier)
- **Version Control**: Git + GitHub
- **CI/CD**: GitHub Actions (later phases)

---

## Claude Code Integration

### Specialized Agents

Use these agents via `@agent-name` for domain-specific tasks:

| Agent | Trigger | Purpose |
|-------|---------|---------|
| **Backend API Builder** | `@backend-api-builder` | FastAPI development: endpoints, services, middleware, testing |
| **Frontend UI Builder** | `@frontend-ui-builder` | Next.js development: components, pages, hooks, animations |
| **Database Designer** | `@database-designer` | PostgreSQL schema, SQLModel models, Alembic migrations |

**Agent Files**: `.claude/agents/`
- `backend-api-builder.md` - FastAPI patterns, SQLModel, JWT middleware
- `frontend-ui-builder.md` - React components, Shadcn/ui, Framer Motion
- `database-designer.md` - Schema design, migrations, query optimization

### Skills Reference

Use these skills for setup and configuration guidance:

| Skill | Location | Purpose |
|-------|----------|---------|
| **FastAPI Setup** | `.claude/skills/fastapi-setup/SKILL.md` | Initialize FastAPI project with UV |
| **Next.js Setup** | `.claude/skills/nextjs-setup/SKILL.md` | Initialize Next.js 16+ with App Router |
| **Shadcn/ui Setup** | `.claude/skills/shadcn-ui-setup/SKILL.md` | Configure component library |
| **Neon DB Setup** | `.claude/skills/neon-db-setup/SKILL.md` | Configure PostgreSQL database |
| **Better Auth** | `.claude/skills/better-auth-integration/SKILL.md` | JWT authentication for both ends |

### CLAUDE.md Hierarchy

The project uses a layered CLAUDE.md structure:

1. **Root CLAUDE.md** (`./CLAUDE.md`)
   - Project overview and phase information
   - Quick commands and spec locations
   - Links to all agents and skills
   
2. **Frontend CLAUDE.md** (`./frontend/CLAUDE.md`)
   - Next.js specific patterns and conventions
   - Component structure and styling rules
   - API client and auth integration
   
3. **Backend CLAUDE.md** (`./backend/CLAUDE.md`)
   - FastAPI specific patterns and conventions
   - SQLModel usage and database access
   - JWT middleware and security rules

**Rule**: Always read root CLAUDE.md first, then subfolder CLAUDE.md for context.

---

## Development Workflow

### 1. Specification Phase (`/sp.specify`)
- Write or update feature specification in `/specs/features/`
- Define user stories with acceptance criteria
- Document API contracts in `/specs/api/`
- Define database schema in `/specs/database/`
- Get user approval before proceeding

### 2. Planning Phase (`/sp.plan`)
- Research technical approach
- Design architecture
- Identify dependencies
- Create implementation plan
- Document in `/specs/[feature]/plan.md`

### 3. Task Generation (`/sp.tasks`)
- Break down plan into testable tasks
- Prioritize tasks by dependency order
- Document in `/specs/[feature]/tasks.md`
- Each task must be independently verifiable

### 4. Implementation Phase (`/sp.implement`)
- Execute tasks in order
- Generate code using Claude Code from specs
- Write tests first (Red phase)
- Implement until tests pass (Green phase)
- Refactor while keeping tests green

### 5. Review Phase
- Run all tests
- Check code quality
- Verify spec compliance
- Create PHR for the session

### 6. Deployment Phase
- Deploy to staging first
- Run smoke tests
- Deploy to production
- Monitor for errors

---

## Code Quality Standards

### Frontend (TypeScript)
```typescript
// ‚úÖ GOOD: Clear, typed, readable
interface Task {
  id: number;
  title: string;
  completed: boolean;
  userId: string;
}

export async function getTasks(userId: string): Promise<Task[]> {
  const response = await api.get(`/api/${userId}/tasks`);
  return response.data;
}
```

```typescript
// ‚ùå BAD: No types, unclear, error-prone
export async function getTasks(id) {
  const res = await fetch("/api/tasks");
  return res.json();
}
```

### Backend (Python)
```python
# ‚úÖ GOOD: Clear, typed, validated
from sqlmodel import SQLModel, Field
from datetime import datetime

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: int | None = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=200)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

```python
# ‚ùå BAD: No validation, no types, unsafe
def create_task(user_id, title):
    db.execute(f"INSERT INTO tasks (user_id, title) VALUES ('{user_id}', '{title}')")
    # SQL injection vulnerability!
```

---

## Error Handling

### Frontend
- Use Error Boundaries for React component errors
- Show user-friendly error messages
- Log errors to console in development
- Send error telemetry in production (optional)

### Backend
- Use FastAPI HTTPException for API errors
- Return consistent error format
- Log all errors with context
- Never expose internal errors to clients

**Error Response Format**:
```json
{
  "success": false,
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Invalid or expired token",
    "details": {}
  }
}
```

---

## Performance Guidelines

### Frontend
- Use Next.js App Router for automatic code splitting
- Lazy load non-critical components
- Optimize images with next/image
- Minimize bundle size
- Use React Server Components where possible
- Implement virtual scrolling for long lists

### Backend
- Use connection pooling for database
- Implement database query optimization
- Add indexes to frequently queried columns
- Use pagination for list endpoints
- Cache static data (optional for Phase 2)
- Set appropriate timeout limits

---

## Security Checklist

- [ ] All API endpoints validate JWT tokens
- [ ] User data is isolated by user_id
- [ ] Passwords are hashed (never stored plain)
- [ ] SQL injection prevented (use ORM)
- [ ] XSS prevented (React auto-escapes)
- [ ] CSRF tokens on mutations (if using cookies)
- [ ] Rate limiting on auth endpoints
- [ ] HTTPS in production
- [ ] Environment variables for secrets
- [ ] No secrets in git repository
- [ ] CORS configured correctly
- [ ] Input validation on all endpoints

---

## Git & Version Control

### Branch Strategy
- `main` - production-ready code
- `feature/[feature-name]` - feature branches
- Create PR for all changes
- Squash commits on merge

### Commit Messages
```
feat: add user authentication with Better Auth
fix: resolve task deletion bug
docs: update API endpoint documentation
refactor: simplify task service logic
test: add integration tests for task API
```

Format: `type: description`
Types: feat, fix, docs, refactor, test, chore

---

## Deployment Strategy

### Phase 2 Deployment
1. **Frontend**: Deploy to Vercel
   - Connect GitHub repository
   - Auto-deploy on push to main
   - Environment variables via Vercel dashboard

2. **Backend**: Deploy to Vercel (Python runtime) or Railway
   - Set up Python runtime
   - Configure DATABASE_URL
   - Set BETTER_AUTH_SECRET

3. **Database**: Neon Serverless PostgreSQL
   - Create project and database
   - Copy connection string to backend env
   - Run migrations

---

## Governance

### Constitution Authority
- This constitution supersedes all other practices
- All code reviews must verify compliance
- Violations must be justified and documented
- Amendments require user approval and documentation

### Change Management
- Constitution changes require new version number
- Document rationale for all amendments
- Update CLAUDE.md to reflect changes
- Communicate changes to all stakeholders

### Complexity Budget
- Justify any complexity beyond MVP requirements
- Simpler alternatives must be considered first
- Document why complexity is necessary
- Review complexity in retrospectives

---

## References

- [Hackathon II Documentation](./hackathon-ii.md)
- [Next.js Documentation](https://nextjs.org/docs)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [SQLModel Documentation](https://sqlmodel.tiangolo.com/)
- [Better Auth Documentation](https://www.better-auth.com/)
- [Shadcn/ui Components](https://ui.shadcn.com/)
- [Aceternity UI](https://ui.aceternity.com/)
- [Framer Motion](https://www.framer.com/motion/)

---

**Version**: 1.0.0 | **Ratified**: 2025-12-11 | **Last Amended**: 2025-12-11
