<!--
Sync Impact Report:
- Version Change: 1.0.0 → 2.0.0 (MAJOR: Phase 3 AI chatbot additions)
- Modified Principles:
  - Principle X → "Stateless Architecture" (NEW for Phase 3)
  - Principle XI → "MCP-First Tool Design" (NEW for Phase 3)
  - Principle XII → "Agent-Centric Design" (NEW for Phase 3)
  - Principle XIII → "Real-Time Streaming (SSE)" (NEW for Phase 3)
  - Principle XIV → "ChatKit UI Integration" (NEW for Phase 3)
  - Principle XV → "Conversation Persistence" (NEW for Phase 3)
- Added Sections:
  - Phase 3 Technology Stack (AI/Agent Framework)
  - Phase 3 Specialized Agents (AI Agent Builder, MCP Server Builder, Chatbot UI Builder)
  - Phase 3 Skills Reference (6 new skills)
  - Natural Language Commands reference
  - Phase 3 Security Checklist additions
- Removed Sections: None (Phase 2 content preserved)
- Templates Status:
  ✅ plan-template.md - Constitution Check reference remains valid
  ✅ spec-template.md - Aligned with spec-driven development principles
  ✅ tasks-template.md - Aligned with test-first and progressive enhancement principles
- Follow-up TODOs: None
-->

# Todo App - Phase 3 Constitution

**Project**: Todo AI Chatbot Application
**Phase**: Phase 3 - AI-Powered Todo Chatbot
**Version**: 2.0.0
**Ratified**: 2025-12-11
**Status**: Active
**Last Amended**: 2025-12-17
**Builds Upon**: Phase 2 Constitution (Full-Stack Web Application)

---

## CLAUDE.md Integration (READ FIRST)

**This constitution is coupled with the CLAUDE.md hierarchy. Before any work:**

1. **Read CLAUDE.md files in order:**
   - `CLAUDE.md` (root) - Master project rules and agent/skill references
   - `frontend/CLAUDE.md` - Frontend-specific guidelines
   - `backend/CLAUDE.md` - Backend-specific guidelines

2. **Use Context7 MCP BEFORE implementation:**
   - Always fetch latest library documentation via Context7
   - Required lookups: `openai-agents-sdk`, `fastmcp`, `openai-chatkit`, `framer-motion`
   - Never assume API patterns - verify first

3. **Delegate to Specialized Agents:**
   - `@ai-agent-builder` for OpenAI Agents SDK + MCP integration
   - `@mcp-server-builder` for FastMCP server development
   - `@chatbot-ui-builder` for ChatKit UI implementation
   - `@backend-api-builder` for FastAPI chat endpoints
   - `@frontend-ui-builder` for Next.js UI components
   - `@database-designer` for database schema changes

4. **Reference Skills for Setup Tasks:**
   - Check `.claude/skills/` before any initialization
   - Phase 3 skills: `openai-agents-setup`, `fastmcp-server-setup`, `chat-api-integration`, `openai-chatkit-setup`, `streaming-sse-setup`, `conversation-management`

**Coupling:** All CLAUDE.md files reference this constitution. This constitution references all CLAUDE.md files. They work together as a unified system.

---

## Project Overview

This is the constitution for the Todo App Hackathon Phase 3, where we transform the Phase 2 web application into an AI-powered chatbot interface for managing todos through natural language. This document defines the principles, standards, and practices that govern the development.

**Goal**: Build a conversational AI interface using OpenAI Agents SDK, FastMCP server, and OpenAI ChatKit that allows users to manage their tasks through natural language commands.

**Phase 3 Adds**:
- AI Agent with OpenAI Agents SDK (using Gemini model)
- MCP Server with task management tools
- ChatKit frontend for conversational interface
- Server-Sent Events (SSE) for real-time streaming
- Conversation history with database persistence

---

## Core Principles (Phase 2 Foundation)

### I. Spec-Driven Development (NON-NEGOTIABLE)

**Description**: Every feature begins with a specification. Implementation follows specification, never precedes it.

**Rules**:
- Write a complete Markdown specification for every feature before any implementation
- Specifications MUST include user stories, acceptance criteria, and success metrics
- No code may be written manually - all implementation MUST be generated by Claude Code from specifications
- Refine specifications until Claude Code generates correct output
- All specifications MUST be version controlled under `/specs` directory

**Rationale**: Spec-driven development ensures clear requirements, maintainable code, and alignment between intent and implementation.

---

### II. Monorepo Architecture

**Description**: Frontend and backend coexist in a single repository with clear boundaries.

**Structure**:
```
/frontend    - Next.js 16+ application (App Router)
/backend     - Python FastAPI application
/specs       - All specifications organized by type
/history     - All PHRs and ADRs
```

**Rules**:
- Each service (frontend/backend) MUST be independently deployable
- Shared types and contracts MUST be documented in `/specs/api`
- No circular dependencies between frontend and backend
- Each service has its own CLAUDE.md with specific guidelines

**Rationale**: Monorepo enables coordinated changes while maintaining clear service boundaries.

---

### III. Test-First Development

**Description**: Tests are written and approved before implementation begins.

**Rules**:
- For every feature, write acceptance tests first
- Tests MUST fail initially (Red phase)
- Implement until tests pass (Green phase)
- Refactor while keeping tests green
- No feature is complete without passing tests
- Minimum test coverage: 80% for backend, 70% for frontend

**Test Pyramid**:
- Backend: Unit tests, integration tests, API contract tests
- Frontend: Component tests, integration tests, E2E tests (critical paths)

**Rationale**: Test-first development catches bugs early and ensures requirements are met.

---

### IV. Authentication & Authorization First

**Description**: Security is foundational, not an afterthought.

**Rules**:
- Implement Better Auth with JWT tokens from the start
- All API endpoints MUST validate JWT tokens
- User isolation: users only access their own data
- Store secrets in environment variables, never in code
- Use HTTPS in production
- Implement rate limiting on authentication endpoints

**Security Standards**:
- Passwords: bcrypt hashing with salt
- JWT: Signed with secret, 7-day expiration
- Sessions: Secure, HttpOnly cookies
- CORS: Whitelist frontend origin only

**Rationale**: Security by design prevents vulnerabilities and data breaches.

---

### V. API-First Design

**Description**: Design and document API contracts before implementation.

**Rules**:
- All API endpoints MUST be documented in `/specs/api/rest-endpoints.md`
- Follow RESTful conventions:
  - GET for retrieval
  - POST for creation
  - PUT for full update
  - PATCH for partial update
  - DELETE for removal
- Return appropriate HTTP status codes
- Use consistent error response format
- Version APIs when breaking changes are needed

**API Response Format**:
```json
{
  "success": true/false,
  "data": { ... },
  "error": { "code": "ERROR_CODE", "message": "Human-readable message" }
}
```

**Rationale**: API-first design ensures frontend and backend can be developed in parallel.

---

### VI. Database-First Schema Design

**Description**: Define database schema before implementing models or queries.

**Rules**:
- Document complete schema in `/specs/database/schema.md`
- Use SQLModel for ORM (combines SQLAlchemy + Pydantic)
- Apply migrations for all schema changes
- Index frequently queried fields
- Enforce foreign key constraints
- Use UUIDs for user IDs, integers for task IDs

**Schema Standards**:
- Every table has: `created_at`, `updated_at` timestamps
- Soft deletes where appropriate (add `deleted_at` field)
- Consistent naming: snake_case for columns
- Document all relationships and constraints

**Rationale**: Schema-first design prevents data integrity issues and migration headaches.

---

### VII. Modern UI/UX Standards

**Description**: Build beautiful, accessible, responsive user interfaces.

**Tech Stack**:
- **Framework**: Next.js 16+ with App Router
- **Styling**: Tailwind CSS 4.0
- **Components**: Shadcn/ui (copy-paste components)
- **Animations**: Framer Motion (smooth transitions)
- **Effects**: Aceternity UI (stunning visual effects)

**Rules**:
- Mobile-first responsive design
- Dark mode support from day one
- Accessibility: WCAG 2.1 Level AA compliance
- Loading states for all async operations
- Error boundaries for graceful error handling
- Optimistic UI updates for better UX

**Performance Standards**:
- First Contentful Paint (FCP) < 1.5s
- Time to Interactive (TTI) < 3.5s
- Lighthouse score > 90

**Rationale**: Modern UI/UX standards create delightful user experiences and professional applications.

---

### VIII. Observability & Debugging

**Description**: Applications must be observable and debuggable in production.

**Rules**:
- Structured logging (JSON format)
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Include request IDs in all logs for tracing
- Log all authentication attempts
- Log all database errors
- Never log sensitive data (passwords, tokens)

**Monitoring**:
- API response times
- Error rates
- Database query performance
- Authentication failures

**Rationale**: Observability enables rapid debugging and performance optimization.

---

### IX. Documentation & Knowledge Capture

**Description**: Every decision, conversation, and architectural choice must be documented.

**Documentation Requirements**:
1. **Prompt History Records (PHRs)**: Record every user interaction and Claude Code session
2. **Architecture Decision Records (ADRs)**: Document significant architectural decisions
3. **README.md**: Setup instructions, tech stack, deployment guide
4. **API Documentation**: Complete endpoint documentation with examples
5. **Component Documentation**: Storybook or similar for UI components

**PHR Creation** (after every user request):
- Route to appropriate subfolder: `history/prompts/{constitution|general|feature-name}/`
- Include: ID, title, stage, user prompt, assistant response, files changed
- Use templates from `.specify/templates/phr-template.prompt.md`

**ADR Suggestion** (for significant decisions):
- Test for significance: Impact + Alternatives + Scope
- Suggest: "Architectural decision detected: [brief] - Document? Run `/sp.adr [title]`"
- Never auto-create; wait for user consent

**Rationale**: Documentation preserves knowledge and accelerates onboarding.

---

## Core Principles (Phase 3 AI Chatbot)

### X. Stateless Architecture (CRITICAL FOR PHASE 3)

**Description**: The chatbot server MUST be completely stateless - all conversation state persists in the database.

**Rules**:
- Server holds NO in-memory conversation state
- Every request includes conversation_id to fetch history from database
- Messages stored in database immediately after generation
- Agent can be restarted without losing conversation context
- MCP tools are stateless - they operate on database state

**Rationale**: Stateless architecture enables horizontal scaling, fault tolerance, and seamless server restarts.

**Implementation Pattern**:
```
1. Receive user message with conversation_id
2. Fetch conversation history from database
3. Build message array (history + new message)
4. Store user message in database
5. Run AI agent with MCP tools
6. Store assistant response in database
7. Return response (stream or complete)
8. Server ready for next request (no state held)
```

---

### XI. MCP-First Tool Design

**Description**: All task operations are exposed as MCP tools that the AI agent calls.

**Rules**:
- Use FastMCP Python SDK for MCP server implementation
- Each tool has clear input schema and return type
- Tools are thin wrappers around database operations
- Tools handle their own error responses
- Never expose raw database errors to AI agent

**MCP Server Architecture**:
- **Phase 3**: MCP Server runs as separate Python process on **port 8001**
- **Phase 4**: MCP Server becomes separate Docker container for Kubernetes deployment
- Agent connects via HTTP: `http://localhost:8001` (Phase 3) or `http://mcp-server:8001` (Phase 4)

**MCP Tools Required**:
| Tool | Purpose | Parameters |
|------|---------|------------|
| `add_task` | Create new task | user_id, title, description? |
| `list_tasks` | Get user's tasks | user_id, status? |
| `complete_task` | Mark task complete | user_id, task_id |
| `delete_task` | Remove task | user_id, task_id |
| `update_task` | Modify task | user_id, task_id, title?, description? |

**Rationale**: MCP standardizes AI-to-application communication and enables tool reuse across different AI frameworks. Separate process architecture is Kubernetes-ready for Phase 4.

---

### XII. Agent-Centric Design

**Description**: The OpenAI Agents SDK agent is the brain that interprets user intent and orchestrates tool calls.

**Rules**:
- Use OpenAI Agents SDK with Gemini model (via AsyncOpenAI wrapper)
- Agent has clear system prompt defining personality and capabilities
- Agent uses @function_tool decorators for MCP tool integration
- Implement AgentHooks and RunHooks for observability
- Use Runner.run() for synchronous execution or Runner.run_streamed() for SSE

**Agent Behavior**:
- Interpret natural language commands
- Call appropriate MCP tools
- Provide friendly, helpful responses
- Confirm actions with users
- Handle errors gracefully

**Rationale**: Centralizing AI logic in the agent ensures consistent behavior and maintainable code.

---

### XIII. Real-Time Streaming (SSE)

**Description**: Use Server-Sent Events for real-time response streaming from AI agent.

**Rules**:
- Implement SSE endpoint for chat responses
- Stream tokens as they're generated by the agent
- Include tool call notifications in stream
- Handle connection drops gracefully
- Support both streaming and non-streaming modes

**SSE Event Format**:
```
event: token
data: {"content": "partial response text"}

event: tool_call
data: {"tool": "add_task", "args": {"title": "..."}}

event: done
data: {"conversation_id": 123, "message_id": 456}
```

**Rationale**: Streaming provides better UX by showing responses as they're generated.

---

### XIV. ChatKit UI Integration

**Description**: Use OpenAI ChatKit for the chat interface frontend.

**Rules**:
- Use OpenAI ChatKit for chatbot UI (as specified in hackathon requirements)
- Configure ChatKit with custom backend endpoint
- Implement themed components for dark mode support
- Add conversation sidebar for thread management
- Use Zustand for conversation state management
- Implement message pagination (50 messages per page, lazy load on scroll)

**UI Strategy**: 90% ChatKit, 10% Custom Fallback
- Primary: Use OpenAI ChatKit components
- Fallback: If ChatKit doesn't work, implement custom chat UI with Shadcn/ui

**Domain Allowlist Configuration (Required for Hosted ChatKit)**:
- **Local Development**: `localhost` works without domain allowlist configuration
- **Production Deployment**:
  1. Deploy frontend to get production URL (Vercel: `https://your-app.vercel.app`)
  2. Add domain to OpenAI allowlist: https://platform.openai.com/settings/organization/security/domain-allowlist
  3. Get ChatKit domain key and add to environment variables

**Environment Variable**:
```
NEXT_PUBLIC_OPENAI_DOMAIN_KEY=your-domain-key-here
```

**Rationale**: ChatKit provides production-ready chat UI components that match OpenAI's design language.

---

### XV. Conversation Persistence

**Description**: Store all conversations and messages in PostgreSQL database.

**Database Models**:

**Conversation**:
- id (int, primary key)
- user_id (string, foreign key -> users.id)
- title (string, optional - auto-generated from first message)
- created_at (timestamp)
- updated_at (timestamp)

**Message**:
- id (int, primary key)
- conversation_id (int, foreign key -> conversations.id)
- role (enum: 'user' | 'assistant' | 'system')
- content (text)
- tool_calls (jsonb, optional)
- created_at (timestamp)

**Rules**:
- Create new conversation if conversation_id not provided
- Auto-generate conversation title from first user message
- Store all messages immediately (don't wait for response)
- Support listing conversations by user
- Support deleting conversations

**Rationale**: Persistent conversations enable history viewing, context continuation, and user experience continuity.

---

### XVI. Progressive Enhancement from Phase 2

**Description**: Build on Phase 2 foundation without breaking existing functionality.

**Rules**:
- Preserve all Phase 2 REST API endpoints
- Add chat endpoint alongside existing APIs
- Share database models and services
- Reuse authentication middleware
- Maintain existing frontend routes

**Phase 3 Additions**:
- `/api/{user_id}/chat` - New chat endpoint
- `/app/chat` - New chat page route
- `Conversation` and `Message` models
- MCP server as separate service
- ChatKit components in frontend

**Rationale**: Progressive enhancement delivers value incrementally without regression.

---

## Technology Stack

### AI & Agent Framework (Phase 3)
- **OpenAI Agents SDK**: 0.1.0+ - Agent orchestration
- **Gemini**: gemini-2.5-flash - LLM model (via OpenAI-compatible API)
- **FastMCP**: Latest - MCP server implementation
- **SSE**: Server-Sent Events - Real-time streaming

### Backend (Phase 2 + Phase 3)
- **Framework**: FastAPI 0.115+
- **Language**: Python 3.13+
- **ORM**: SQLModel 0.0.24+ (SQLAlchemy 2.0 + Pydantic 2.0)
- **Database**: Neon Serverless PostgreSQL
- **Authentication**: Better Auth (JWT tokens)
- **Validation**: Pydantic 2.0
- **Testing**: pytest 8.0+, httpx (for API tests)
- **Package Manager**: UV (fast Python package manager)

### Frontend (Phase 2 + Phase 3)
- **Framework**: Next.js 16+ (App Router, Server Components, Server Actions)
- **Language**: TypeScript 5.0+
- **Styling**: Tailwind CSS 4.0
- **Components**: Shadcn/ui (Radix UI primitives)
- **Animation**: Framer Motion 11+
- **Effects**: Aceternity UI (stunning visual effects)
- **Forms**: React Hook Form + Zod validation
- **HTTP Client**: Axios 1.7+ (MANDATORY - NO fetch for API calls)
- **State**: Zustand 5.0+ (MANDATORY - NO React Context for state)
- **Chat UI**: @openai/chatkit-react (Phase 3)

### Infrastructure
- **Frontend Hosting**: Vercel
- **Backend Hosting**: Vercel (Python runtime) or Railway
- **Database**: Neon Serverless PostgreSQL (free tier)
- **Version Control**: Git + GitHub
- **CI/CD**: GitHub Actions (later phases)

---

## Claude Code Integration

### Phase 2 Specialized Agents

| Agent | Trigger | Purpose |
|-------|---------|---------|
| **Backend API Builder** | `@backend-api-builder` | FastAPI development: endpoints, services, middleware, testing |
| **Frontend UI Builder** | `@frontend-ui-builder` | Next.js development: components, pages, hooks, animations |
| **Database Designer** | `@database-designer` | PostgreSQL schema, SQLModel models, Alembic migrations |

### Phase 3 Specialized Agents

| Agent | Trigger | Purpose |
|-------|---------|---------|
| **AI Agent Builder** | `@ai-agent-builder` | OpenAI Agents SDK, MCP integration, Gemini config |
| **MCP Server Builder** | `@mcp-server-builder` | FastMCP server, tool definitions |
| **Chatbot UI Builder** | `@chatbot-ui-builder` | ChatKit integration, conversation UI |

**Agent Files**: `.claude/agents/`
- `backend-api-builder.md` - FastAPI patterns, SQLModel, JWT middleware
- `frontend-ui-builder.md` - React components, Shadcn/ui, Framer Motion
- `database-designer.md` - Schema design, migrations, query optimization
- `ai-agent-builder.md` - OpenAI Agents + MCP patterns
- `mcp-server-builder.md` - FastMCP server development
- `chatbot-ui-builder.md` - ChatKit UI integration

### Phase 2 Skills Reference

| Skill | Location | Purpose |
|-------|----------|---------|
| **FastAPI Setup** | `.claude/skills/fastapi-setup/SKILL.md` | Initialize FastAPI project with UV |
| **Next.js Setup** | `.claude/skills/nextjs-setup/SKILL.md` | Initialize Next.js 16+ with App Router |
| **Shadcn/ui Setup** | `.claude/skills/shadcn-ui-setup/SKILL.md` | Configure component library |
| **Neon DB Setup** | `.claude/skills/neon-db-setup/SKILL.md` | Configure PostgreSQL database |
| **Better Auth** | `.claude/skills/better-auth-integration/SKILL.md` | JWT authentication for both ends |

### Phase 3 Skills Reference

| Skill | Location | Purpose |
|-------|----------|---------|
| **OpenAI Agents Setup** | `.claude/skills/openai-agents-setup/SKILL.md` | Initialize agent with Gemini |
| **FastMCP Server Setup** | `.claude/skills/fastmcp-server-setup/SKILL.md` | Create MCP server |
| **Chat API Integration** | `.claude/skills/chat-api-integration/SKILL.md` | Chat endpoint + agent |
| **OpenAI ChatKit Setup** | `.claude/skills/openai-chatkit-setup/SKILL.md` | ChatKit React components |
| **Streaming SSE Setup** | `.claude/skills/streaming-sse-setup/SKILL.md` | SSE implementation |
| **Conversation Management** | `.claude/skills/conversation-management/SKILL.md` | History UI |

### CLAUDE.md Hierarchy

The project uses a layered CLAUDE.md structure:

1. **Root CLAUDE.md** (`./CLAUDE.md`)
   - Project overview and phase information
   - Quick commands and spec locations
   - Links to all agents and skills
   - Updated for Phase 3 agents and skills

2. **Frontend CLAUDE.md** (`./frontend/CLAUDE.md`)
   - Next.js specific patterns and conventions
   - Component structure and styling rules
   - API client and auth integration
   - ChatKit integration patterns (Phase 3)

3. **Backend CLAUDE.md** (`./backend/CLAUDE.md`)
   - FastAPI specific patterns and conventions
   - SQLModel usage and database access
   - JWT middleware and security rules
   - Agent and MCP patterns (Phase 3)

**Rule**: Always read root CLAUDE.md first, then subfolder CLAUDE.md for context.

---

## Development Workflow

### 1. Specification Phase (`/sp.specify`)
- Write or update feature specification in `/specs/features/`
- Define user stories with acceptance criteria
- Document API contracts in `/specs/api/`
- Define database schema in `/specs/database/`
- Get user approval before proceeding

### 2. Planning Phase (`/sp.plan`)
- Research technical approach
- Design architecture
- Identify dependencies
- Create implementation plan
- Document in `/specs/[feature]/plan.md`

### 3. Task Generation (`/sp.tasks`)
- Break down plan into testable tasks
- Prioritize tasks by dependency order
- Document in `/specs/[feature]/tasks.md`
- Each task MUST be independently verifiable

### 4. Implementation Phase (`/sp.implement`)
- Execute tasks in order
- Generate code using Claude Code from specs
- Write tests first (Red phase)
- Implement until tests pass (Green phase)
- Refactor while keeping tests green

### 5. Review Phase
- Run all tests
- Check code quality
- Verify spec compliance
- Create PHR for the session

### 6. Deployment Phase
- Deploy to staging first
- Run smoke tests
- Deploy to production
- Monitor for errors

---

## Natural Language Commands (Phase 3)

The chatbot should understand and respond to:

| User Says | Agent Should Do |
|-----------|-----------------|
| "Add a task to buy groceries" | Call add_task with title "Buy groceries" |
| "Show me all my tasks" | Call list_tasks with status "all" |
| "What's pending?" | Call list_tasks with status "pending" |
| "Mark task 3 as complete" | Call complete_task with task_id 3 |
| "Delete the meeting task" | Call list_tasks first, then delete_task |
| "Change task 1 to 'Call mom tonight'" | Call update_task with new title |
| "I need to remember to pay bills" | Call add_task with title "Pay bills" |
| "What have I completed?" | Call list_tasks with status "completed" |

---

## Code Quality Standards

### Agent Code (Python - Phase 3)
```python
# GOOD: Clear agent definition with typed tools
from agents import Agent, Runner, function_tool
from agents.extensions.models.litellm import LitellmModel

model = LitellmModel(model="gemini/gemini-2.5-flash", api_key=GEMINI_API_KEY)

@function_tool
async def add_task(user_id: str, title: str, description: str = "") -> dict:
    """Add a new task for the user."""
    result = await mcp_client.call_tool("add_task", {
        "user_id": user_id,
        "title": title,
        "description": description
    })
    return result

agent = Agent(
    name="TodoBot",
    instructions="You are a helpful todo assistant...",
    model=model,
    tools=[add_task, list_tasks, complete_task, delete_task, update_task]
)
```

### MCP Server Code (Python - Phase 3)
```python
# GOOD: Clean MCP tool definition
from fastmcp import FastMCP
from sqlmodel import Session, select

mcp = FastMCP("Todo MCP Server")

@mcp.tool()
async def add_task(user_id: str, title: str, description: str = "") -> dict:
    """Create a new task for the user."""
    async with get_session() as session:
        task = Task(user_id=user_id, title=title, description=description)
        session.add(task)
        await session.commit()
        await session.refresh(task)
        return {"task_id": task.id, "status": "created", "title": task.title}
```

### ChatKit Frontend (TypeScript - Phase 3)
```typescript
// GOOD: Chat interface with Zustand state management
// Note: Verify exact ChatKit package import from OpenAI documentation
'use client';

import { useConversationStore } from '@/stores/conversation-store';

export function ChatInterface() {
  const { currentConversation, messages, sendMessage, isStreaming } = useConversationStore();

  const handleSendMessage = async (content: string) => {
    await sendMessage({
      conversationId: currentConversation?.id,
      message: content,
    });
  };

  return (
    <div className="flex flex-col h-full">
      {/* Message list */}
      <div className="flex-1 overflow-y-auto">
        {messages.map((msg) => (
          <MessageBubble key={msg.id} message={msg} />
        ))}
      </div>

      {/* Input area - integrate with ChatKit components */}
      <ChatInput onSend={handleSendMessage} disabled={isStreaming} />
    </div>
  );
}
```

### Frontend (TypeScript - Phase 2)
```typescript
// GOOD: Clear, typed, readable
interface Task {
  id: number;
  title: string;
  completed: boolean;
  userId: string;
}

export async function getTasks(userId: string): Promise<Task[]> {
  const response = await api.get(`/api/${userId}/tasks`);
  return response.data;
}
```

### Backend (Python - Phase 2)
```python
# GOOD: Clear, typed, validated
from sqlmodel import SQLModel, Field
from datetime import datetime

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: int | None = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=200)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

---

## Error Handling

### Frontend
- Use Error Boundaries for React component errors
- Show user-friendly error messages
- Log errors to console in development
- Send error telemetry in production (optional)

### Backend
- Use FastAPI HTTPException for API errors
- Return consistent error format
- Log all errors with context
- Never expose internal errors to clients

### AI/Agent Layer (Phase 3)
- Catch and handle agent errors
- Return error messages, not exceptions from tools
- Provide actionable error messages to users
- Log all tool calls for audit trail

**Error Response Format**:
```json
{
  "success": false,
  "error": {
    "code": "AGENT_ERROR",
    "message": "I'm sorry, I couldn't complete that action. Please try again.",
    "details": {}
  }
}
```

---

## Performance Guidelines

### Frontend
- Use Next.js App Router for automatic code splitting
- Lazy load non-critical components
- Optimize images with next/image
- Minimize bundle size
- Use React Server Components where possible
- Implement virtual scrolling for long lists

### Backend
- Use connection pooling for database
- Implement database query optimization
- Add indexes to frequently queried columns
- Use pagination for list endpoints
- Cache static data (optional for Phase 2)
- Set appropriate timeout limits

### AI/Chat (Phase 3)
- Implement SSE for streaming responses
- Use message pagination (50 per page)
- Cache conversation history lookup
- Implement rate limiting: 30 messages/minute per user

---

## Security Checklist

### Phase 2 Security
- [ ] All API endpoints validate JWT tokens
- [ ] User data is isolated by user_id
- [ ] Passwords are hashed (never stored plain)
- [ ] SQL injection prevented (use ORM)
- [ ] XSS prevented (React auto-escapes)
- [ ] CSRF tokens on mutations (if using cookies)
- [ ] Rate limiting on auth endpoints
- [ ] HTTPS in production
- [ ] Environment variables for secrets
- [ ] No secrets in git repository
- [ ] CORS configured correctly
- [ ] Input validation on all endpoints

### Phase 3 Security (Chat-Specific)
- [ ] Chat endpoints validate JWT tokens
- [ ] User can only access their own conversations
- [ ] MCP tools validate user_id ownership
- [ ] Message content length limited (max 4000 characters)
- [ ] Rate limiting on chat endpoints (30 msg/min)
- [ ] Tool calls logged for audit
- [ ] No sensitive data in agent responses
- [ ] SSE connections properly authenticated
- [ ] Input sanitization to prevent prompt injection

---

## Git & Version Control

### Branch Strategy
- `main` - production-ready code
- `phase3/[task-name]` - Phase 3 feature branches
- Create PR for all changes
- Squash commits on merge

### Commit Messages
```
feat: add AI chatbot with MCP integration
fix: resolve SSE streaming bug
docs: update API endpoint documentation
refactor: simplify agent tool logic
test: add integration tests for chat API
```

Format: `type: description`
Types: feat, fix, docs, refactor, test, chore

---

## Deployment Strategy

### Phase 3 Deployment
1. **Frontend**: Deploy to Vercel
   - Connect GitHub repository
   - Auto-deploy on push to main
   - Environment variables via Vercel dashboard
   - Add ChatKit domain key for production

2. **Backend**: Deploy to Vercel (Python runtime) or Railway
   - Set up Python runtime
   - Configure DATABASE_URL
   - Set BETTER_AUTH_SECRET
   - Set GEMINI_API_KEY

3. **MCP Server**: Run as separate process
   - Port 8001 for Phase 3
   - Future: Docker container for Phase 4

4. **Database**: Neon Serverless PostgreSQL
   - Run migrations for Conversation/Message tables
   - Verify indexes on conversation_id, user_id

---

## Environment Variables (Phase 3 Additions)

```env
# AI/Agent Configuration
GEMINI_API_KEY=your_gemini_api_key
GEMINI_MODEL=gemini-2.5-flash

# MCP Server
MCP_SERVER_URL=http://localhost:8001/mcp
MCP_SERVER_PORT=8001

# ChatKit (Frontend - for production deployment)
NEXT_PUBLIC_OPENAI_DOMAIN_KEY=your-domain-key-here

# Existing Phase 2 variables remain unchanged
DATABASE_URL=postgresql+asyncpg://...
BETTER_AUTH_SECRET=...
CORS_ORIGINS=http://localhost:3000
```

---

## Governance

### Constitution Authority
- This constitution supersedes all other practices
- Phase 2 constitution remains valid for non-chat features
- All code reviews MUST verify compliance
- Violations MUST be justified and documented
- Amendments require user approval and documentation

### Change Management
- Constitution changes require new version number
- Document rationale for all amendments
- Update CLAUDE.md to reflect changes
- Communicate changes to all stakeholders

### Complexity Budget
- Justify any complexity beyond MVP requirements
- Simpler alternatives MUST be considered first
- Document why complexity is necessary
- Review complexity in retrospectives

---

## References

- [Phase 3 Constitution Source](./constitution-prompt-phase-3.md)
- [Phase 2 Constitution](./prompts/constitution-prompt-phase-2.md)
- [OpenAI Agents SDK Documentation](https://openai.github.io/openai-agents-python/)
- [FastMCP Documentation](https://github.com/jlowin/fastmcp)
- [OpenAI ChatKit Documentation](https://platform.openai.com/docs/guides/chatkit)
- [Server-Sent Events MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- [Next.js Documentation](https://nextjs.org/docs)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [SQLModel Documentation](https://sqlmodel.tiangolo.com/)
- [Better Auth Documentation](https://www.better-auth.com/)
- [Shadcn/ui Components](https://ui.shadcn.com/)

---

**Version**: 2.0.0 | **Ratified**: 2025-12-11 | **Last Amended**: 2025-12-17
